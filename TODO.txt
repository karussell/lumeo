das fremde kind -> bibo buch, xyxylÃ¶nnaeus

1. make things thread safe. 
   implement atomic UPDATE
   think about order + semi transaction support
   lock access to put - adding an edge is not an atomic access to the map
   delete + put may result in missing or duplicate entries

2. improve ID lookup performance
   lucene already has a cache but we need to access documents via ID
    improve ID lookup via LUCENE 4.0 see http://blog.mikemccandless.com/2010/06/lucenes-pulsingcodec-on-primary-key.html
        indexWriterConfig.setCodecProvider()
   faster field fetching via doc values
      http://www.searchworkings.org/blog/-/blogs/introducing-lucene-index-doc-values
      http://www.slideshare.net/lucenerevolution/willnauer-simon-doc-values-column-stride-fields-in-lucene
   use OpenBitSet bloomFilter

3. use blueprint tests to see what fails


check if lucene searchers/readers are properly closed

use CachingWrapperFilter

instead of storing -> use only one _source field

use FilteredDocIdSet to better traverse a prefiltered graph

remove difference of edge and vertex in/out ? 
    this or something else would be necessary if we introduce shortcut from vertex to vertex
    or should we simple implement a hypergraph possibility (edge could then have multiple vertices not only 2 => no real difference then)

use trove collection where possible (e.g. for uncommited buffer?)