check again lock mechanism
    => avoid wait + notifyAll (replace with different mechism -> yield?) => faster indexing

java.util.ConcurrentModificationException
	at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
	at java.util.AbstractList$Itr.next(AbstractList.java:343)
	at org.apache.lucene.document.Document.get(Document.java:167)
	at de.jetsli.lumeo.RawLucene.flush(RawLucene.java:429)
	at de.jetsli.lumeo.RawLucene$FlushThread.run(RawLucene.java:506)

make blueprint tests running

have a look into http://kasparov.skife.org/lucene/graph/

improve ID lookup performance
   lucene already has a cache but we need to access documents via ID
   know what we do not have via OpenBitSet bloomFilter
   LUCENE 4.0
      improve ID lookup http://blog.mikemccandless.com/2010/06/lucenes-pulsingcodec-on-primary-key.html
         indexWriterConfig.setCodecProvider()
      faster field fetching via doc values
         http://www.searchworkings.org/blog/-/blogs/introducing-lucene-index-doc-values
         http://www.slideshare.net/lucenerevolution/willnauer-simon-doc-values-column-stride-fields-in-lucene   

use lumeo for luxperiment

PROBLEM: if an error is happening while an edge creation => rollback previous changes -> complicated as properties are overwritten too

caching/filtering
    use CachingWrapperFilter
    use FilteredDocIdSet to better traverse a prefiltered graph

instead of storing -> use only one _source field

remove difference of edge and vertex in/out ? 
    this or something else would be necessary if we introduce shortcut from vertex to vertex
    or should we simple implement a hypergraph possibility (edge could then have multiple vertices not only 2 => no real difference then)

use trove collection where possible (e.g. for uncommited buffer?)